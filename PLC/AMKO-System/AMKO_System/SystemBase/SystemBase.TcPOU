<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.5">
  <POU Name="SystemBase" Id="{147e2f75-a8ca-43e4-acf3-ce2169ee9c02}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'reflection'}
PROGRAM SystemBase // system base program, from here all modules are controlled and the system functions are called.
VAR_INPUT 
	nCmdModulesConected : UDINT := 1 ; // number of modules connected to system
END_VAR
VAR	// Fault indications
	bMissingCond	: BOOL := FALSE ; // Module missing condition active
	bFatalFault		: BOOL := FALSE ; // Module fatal fault is active
	bCycleFault		: BOOL := FALSE ; // Module cycle fault is active

	// Check values
	bReferenceOk	: BOOL := FALSE ; // All module references  have been checked

	// State indication
	bSafeStopping	: BOOL := false ; // Module is stopping by safety
	bIsSafe			: BOOL := FALSE ; // Module is safe and locked until safety is ok
	bNoreference	: BOOL := FALSE ; // Module Startup Undefined initialization required

	bInitializing	: BOOL := FALSE ; // Module startup initializing
	binitialized	: BOOL := FALSE ; // Module startup initialized waiting for startup command

	bIdle 			: BOOL := FALSE ; // Module startup Idle no commands active

	bEnabling 		: BOOL := FALSE ; // Module Startup enabeling 
	bEnabled 		: BOOL := FALSE ; // Module Startup Enabled
	
	bHoming			: BOOL := FALSE ; // Module startup homing back to base position and recalibrate
	bHomed 			: BOOL := FALSE ; // Module startup homed waiting for further further commands

	bHolding 		: BOOL := FALSE ; // Module Module Hold motion command executing
	bHeld	 		: BOOL := FALSE ; // Module Hold Motion is held until command is released	
	
	bResetting 		: BOOL := FALSE ; // Module Reset resetting error status
	bResetDone 		: BOOL := FALSE ; // Module reset is done   

	bManual 		: BOOL := FALSE ; // Module Work status Module in Manual 
	
	bStartSemiAuto	: BOOL := FALSE ; // Start semi automatic mode 
	bSemiAuto		: BOOL := FALSE ; // Module work status module in semi automatic
	
	bStartAuto		: BOOL := FALSE ; // Start automatic mode
	bAutomatic 		: BOOL := FALSE ; // Module Work status Module in Automatic mode
	
	bPoweringOff	: BOOL := FALSE ; // Module is powering off
	bPowerdOff		: BOOL := FALSE ; // Module has powerd off 	

END_VAR
VAR
	// System inputs 
	ibPowerSupplyOk	 	AT%I*	: BOOL  ; // System Power supply is ok 
	iSystemSafetyFault	AT%I*	: BOOL	; // System safety Fault
	fbAirpressureOk 			: Fb_DevDigitalInputFunctions  	; // system airpressure is ok
	fbCmdResetSafety		 	: FB_DevPushbuttonLight 		; // System reset
	
	fTrigPowerSupply	: F_TRIG ; // falling edge trigger for power supply
	// System safety valve
	fbValveMainAirSupply		: FB_DevValve ; // Main air supply valve 
	
	// System HMI commands
	fbStartSemiAuto				: FB_DevHMIButton ; // HMI start semi automatic button 
	fbStartAuto					: FB_DevHMIButton ; // Hmi start automatic button
	
	// system Commands 
	fbCmdStartSystem		 	: FB_DevPushbuttonLight  		; // (re)start system input from button
	fbCmdStartAuto				: FB_DevPushbuttonLight			; // Start system automatic cycle
	fbCmdStartManual			: FB_DevHMIButton 				; // Start system in manual mode 
	fbCmdPowerOff				: FB_DevHMIButton 				; // Power off system
	
	//System state
	bSystemOK					: BOOL := FALSE ; // all safety and vitals are OK
	eStateSystem				: E_StateSystem := E_StateSystem.NoReference ; // State of system

	// Set system variables
	fbSetSystemVariables		: Fb_SystemVariables ;
	
	// System Fault handling
	fbSystemFaultHandler		: Fb_SystemFaultHandler ;
	fbOperatorMessage			: FB_OperatorMessageDisplay ; //Operator message or system state message hadler 

	// Local Fault Handling
	fbFaultHandler				: 	Fb_FaultHandler 		; // Fault handler 
	stMessage					: UDT_Fault			; // Message data

 	// Module states
	nNumberOfModules			: UDINT := 0 ; // Number of modules added to the system 
	arpModules					: ARRAY [0..gvl_main.cnMaxNUMBEROFMODULES] OF Udt_ModuleId ; 

	// power down system function
	ntShutDown					: NT_Shutdown ; // shutdown system function 

	// Manual controller
	bDevicesAddedtoManual 		: BOOL := FALSE ; // Add system device (buttons) to manual controller
	

	// Function path 
	{attribute 'instance-path'} 
    {attribute 'noinit'}
	sPath			: STRING	; // Path name of function (used for manual reference
END_VAR
VAR // safety 
	// inputs 
	ibEstopOk 			AT%I*	: BOOL  ; // system emergency stop ok
	ibSystemSafetyOK	AT%I*	: BOOL  ; // System is safe 
	iEstopFunctionFault AT%I*	: BOOL	; // Emergency stop function fault (wiring or edm fault)
	iGeneralSafetyFault	AT%I*	: BOOL	; // General safety program fault
	
	// Outputs 
	qbSafetyErrAckn		AT%Q*	: BOOL ; // Safety error acknowledge
	qbRunSafety			AT%Q*	: BOOL ; // Run safety program
	qbResetSafety		AT%Q*	: BOOL ; // reset safety program

	// safety Reset Timer	
	TofSafetyErrAck				: TOF := (PT := T#500MS); // Safety reset timer
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Exec safety control
ExecSafetyControl();

// check if all modules are connected else return  
IF nNumberOfModules < nCmdModulesConected - 1 THEN 
	RETURN;
END_IF

// check functions
CheckSystemOK();

// Run system
ExecSystemRun();

// call device functions 
CallSystemFunctions();

// Call modules 
CallModules();]]></ST>
    </Implementation>
    <Folder Name="ModuleFunctions" Id="{fb1414af-f6e5-4202-8989-256aa0d1eacc}" />
    <Folder Name="SystemFunction" Id="{05994c64-d0aa-4e7d-8ae3-f139ae256daf}" />
    <Method Name="CallModules" Id="{7e8c963f-d98c-43d0-a3ed-11f16c2d5b4d}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE CallModules : BOOL
VAR
	i : UDINT ;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set base conditions
bReferenceOk	:= TRUE ;
bIsSafe			:= TRUE ;
bIdle			:= TRUE ;	
bHeld			:= TRUE ;
bResetDone 		S= bResetting	;
bManual			:= TRUE	;
bSemiAuto		:= TRUE ;
bAutomatic		:= FALSE;
bEnabled		S= bEnabling ;
bPowerdOff		:= TRUE;
bHomed 			:= TRUE;

// copy inputs to modules 
FOR i := 0 TO nNumberOfModules DO 
	// set system commands
	arpModules[i].pFunction^.bEnable			:= bEnabled		;
	arpModules[i].pFunction^.bCmdReset			:= bResetting	;
	arpModules[i].pFunction^.bSafetyOK			:= bSystemOK	;
	// Read state indications 
	bReferenceOk 	:= arpModules[i].pFunction^.bReferenceOk 	AND bReferenceOk; 
	bIsSafe 		:= arpModules[i].pFunction^.bIsSafe 		AND bIsSafe		;
	bEnabled 		:= arpModules[i].pFunction^.bEnable 		AND bEnabled	;
	bHeld			:= arpModules[i].pFunction^.bHeld 			AND bHeld		;
	bResetDone		:= arpModules[i].pFunction^.bResetDone 		AND bResetDone	;
	bManual			:= arpModules[i].pFunction^.bManual 		AND bManual		;
	bSemiAuto		:= arpModules[i].pFunction^.bSemiAuto 		AND bSemiAuto	;
	bAutomatic		:= arpModules[i].pFunction^.bAutomatic 		OR bAutomatic	;
	bStartAuto		:= NOT arpModules[i].pFunction^.bAutomatic 	AND bStartAuto	;
	bPowerdOff 		:= arpModules[i].pFunction^.bPowerdOff 		AND bPowerdOff	;
	bHomed			:= arpModules[i].pFunction^.bHomed			AND bHomed 		;
END_FOR

// Reset start inputs
	bEnabling		R= bEnabled 	;
	bHolding		R= bHeld 		;
	bResetting		R= bResetDone 	;
	bStartSemiAuto	R= bSemiAuto	;
	bPoweringOff	R= bPowerdOff 	;
	bHoming			R= bHomed 		;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CallSystemFunctions" Id="{5be4e1d6-b194-4082-99a1-645b475d1410}" FolderPath="SystemFunction\">
      <Declaration><![CDATA[METHOD PRIVATE CallSystemFunctions : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set system variables 
fbSetSystemVariables();

// call parameter handler
GVL_Parameters.fbParameterHandler();
GVL_DevManual.fbManualControler();

// Execute button functions 
fbStartAuto		( refFbFault := fbFaultHandler );
fbStartSemiAuto ( refFbFault := fbFaultHandler ); 

fbCmdStartSystem(refFbFault := fbFaultHandler);
fbCmdStartAuto	(refFbFault := fbFaultHandler);
// execute input functions
fbAirpressureOk(refFbFault := fbFaultHandler);
fbValveMainAirSupply(	bEnable		:= TRUE,
						bSafetyOk	:= ibEstopOk,
						refFbFault 	:= fbFaultHandler);
// Call persistent data handler 
DataManager.FbPersistentManager();

// Add device functions to manual controller 
IF NOT bDevicesAddedtoManual THEN
	GVL_DevManual.fbManualControler.CmdAddDevice( refToDevice := fbAirpressureOk 	);
	GVL_DevManual.fbManualControler.CmdAddDevice( refToDevice := fbCmdStartSystem	);
	GVL_DevManual.fbManualControler.CmdAddDevice( refToDevice := fbCmdStartAuto		);
	GVL_DevManual.fbManualControler.CmdAddDevice( refToDevice := fbCmdResetSafety	);
	bDevicesAddedtoManual S= TRUE ;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckSystemOK" Id="{b3d7881d-8420-47b1-9d4b-1c3829d8822d}" FolderPath="SystemFunction\">
      <Declaration><![CDATA[METHOD PRIVATE CheckSystemOK : BOOL
VAR
	i : UDINT ;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// shutdown emediately if power is down 
fTrigPowerSupply(CLK := ibPowerSupplyOk);
ntShutDown(START := bPowerdOff OR fTrigPowerSupply.Q);

// Call faulthandler
fbSystemFaultHandler( 	nNumberOfModules	:= nNumberOfModules,
						arpModules			:= arpModules,
						bSystemFF			=> bFatalFault,
						bSystemCF			=> bCycleFault,
						bSystemMC			=> bMissingCond);
				
// Check system safety and Faults
IF NOT ibEstopOk 
	OR NOT ibPowerSupplyOk 
	OR bFatalFault
	OR fbCmdResetSafety.bFcoDelay 
	OR bSafeStopping THEN  
	ExecSafeStop();
ELSIF NOT ibSystemSafetyOK 
	OR NOT fbAirpressureOk.bFcoDelay 
	OR bCycleFault 
	OR (bHolding AND NOT bIsSafe) THEN
	ExecSafeHold();
ELSIF (bIsSafe OR bHeld)  THEN 
	bSystemOK S= TRUE ;	
END_IF

bSystemOK R= NOT (ibEstopOk AND ibPowerSupplyOk AND ibSystemSafetyOK AND fbAirpressureOk.bFcoDelay);


// Main air control 
IF ibEstopOk AND 
	ibSystemSafetyOK AND 
	ibPowerSupplyOk AND
	binitialized THEN 
fbValveMainAirSupply.CmdOpen();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdAddModule" Id="{02c45d8a-a400-4bf9-96fe-fbe272a81730}">
      <Declaration><![CDATA[METHOD PUBLIC CmdAddModule : BOOL
VAR_INPUT
	refToModule : REFERENCE TO Fb_ModuleBase ; // reference to module function
END_VAR
VAR
	bModuleAdded	: BOOL ;
	i 				: UDINT ; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check if device is not already in the array 
FOR i:= 0 TO GVL_Main.cnMaxNUMBEROFMODULES DO
	IF arpModules[i].pFunction = 0 THEN 
		nNumberOfModules:= i;
		EXIT;	
	ELSIF arpModules[i].sName = refToModule.sName THEN 
		bModuleAdded := TRUE ;
	END_IF 
END_FOR

// If device is not found add device to the list
IF NOT bModuleAdded THEN 
	nNumberOfModules := LIMIT(0, nNumberOfModules,GVL_Main.cnMaxNUMBEROFMODULES)	;
	arpModules[nNumberOfModules].nNumber 	:= refToModule.nModuleID;
	arpModules[nNumberOfModules].sName		:= refToModule.sName	;
	arpModules[nNumberOfModules].pFunction 	:= ADR(refToModule)		;	
	bModuleAdded := TRUE ;
END_IF

CmdAddModule := bModuleAdded ; ]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecAutomatic" Id="{3c758811-81f1-42d1-83e5-646cc80a7b4f}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecAutomatic : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Run automatic function in 
FOR i := 0 TO nNumberOfModules DO 
	arpModules[i].pFunction^.CmdAutomatic() ;
END_FOR

ExecAutomatic := bAutomatic;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecHoming" Id="{345df0e0-469c-4aba-9303-ad14c7d3f6d3}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecHoming : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Home all modules
FOR i := 0 TO nNumberOfModules DO 
	IF NOT arpModules[i].pFunction^.bHomed THEN 
		arpModules[i].pFunction^.CmdHome();
	END_IF
END_FOR
 
ExecHoming := bHomed ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecManual" Id="{1eeb2405-fd6d-491e-8ef7-e639f5684ed3}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PUBLIC ExecManual : BOOL
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bEnabled := FALSE ;
// Run automatic function in 
FOR i := 0 TO nNumberOfModules DO 
	arpModules[i].pFunction^.CmdManual() ;
END_FOR

ExecManual := bManual;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecPowerOff" Id="{b17ea916-e40f-4a32-a9b5-a5ade237754d}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecPowerOff : BOOL
VAR_INPUT
END_VAR
VAR 
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Power off all modules
FOR i := 0 TO nNumberOfModules DO 
	arpModules[i].pFunction^.CmdPowerOff () ;
END_FOR
 
ExecPowerOff := bPowerdOff ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSafeHold" Id="{09e80f99-469c-4643-bf23-6284454a47bf}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecSafeHold : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Hold all modules
bStartAuto		:= FALSE;

FOR i := 0 TO nNumberOfModules DO 
	arpModules[i].pFunction^.CmdHold();
END_FOR

ExecSafeHold := bHeld ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSafeReset" Id="{1f949173-b753-460e-b2f0-a3f94b7a8c12}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecSafeReset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSafeStop" Id="{231fd871-3511-471c-84e1-00de0d5b0d2d}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE ExecSafeStop : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// perform Estop for all modules
bEnabled		:= FALSE;
bEnabling		:= FALSE;
bInitializing	:= FALSE;
bHoming			:= FALSE;
bStartAuto		:= FALSE;
bStartSemiAuto	:= FALSE;

// Close and vent main air supply
fbValveMainAirSupply.CmdClose();

// Module safe stop
IF binitialized AND bReferenceOk THEN 
	FOR i := 0 TO nNumberOfModules DO 
		arpModules[i].pFunction^.CmdEstop();
	END_FOR
END_IF

bSafeStopping 	:= NOT bIsSafe ;

IF bIsSafe THEN 
	fbValveMainAirSupply.CmdSafeStop();
END_IF
 
ExecSafeStop := bIsSafe ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSafetyControl" Id="{8ec10b67-53de-4590-9578-2159b6a13b3f}" FolderPath="SystemFunction\">
      <Declaration><![CDATA[METHOD PRIVATE ExecSafetyControl : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Set safety state and button light state
fbCmdResetSafety.bEnable S= TRUE ;
IF NOT ibEstopOk THEN 
	GVL_HMI.bEstopActive 	:= TRUE ;
	GVL_HMI.sCmdEstopText 	:= 'Emergency Stop Pressed';
	fbCmdResetSafety.CmdOn() ;
ELSIF NOT ibSystemSafetyOK THEN 
	fbCmdResetSafety.CmdBlinkSlow() ;
ELSIF NOT fbAirpressureOk.bFcoDelay OR NOT bSystemOK THEN
	fbCmdResetSafety.CmdBlinkFast() ;
END_IF


// Safety reset button function
fbCmdResetSafety(refFbFault := fbFaultHandler); 

// Set HMI
IF NOT bSystemOK THEN 
	GVL_HMI.bEstopActive 	:= TRUE ;
END_IF

// Link Safetty Reset
qbResetSafety := fbCmdResetSafety.bFeStatus ;

// Set safety system in run mode
IF NOT iGeneralSafetyFault THEN 
	qbRunSafety := TRUE ;
ELSE 
	qbRunSafety := FALSE;
END_IF

// reset safety faults
TofSafetyErrAck(IN := qbSafetyErrAckn);
IF iGeneralSafetyFault THEN 
	GVL_HMI.bEstopActive 	:= TRUE ;
	GVL_HMI.sCmdEstopText 	:= 'Safety Program fault';
	IF NOT qbSafetyErrAckn AND NOT TofSafetyErrAck.Q THEN 
		qbSafetyErrAckn := TRUE; 
	ELSE
		qbSafetyErrAckn := FALSE; 
	END_IF
	stMessage.Active := TRUE ;
	stMessage.ComponentType	:= E_ComponentTypes.SafeIO ;
	stMessage.Discription	:= 'Safety program is in fault state. Check wiring ';
	stMessage.LocationName	:= 'Main safety';
	stMessage.LocationNumber:= 1;
	stMessage.FaultType		:= Utilities_Library.E_FaultTypes.FF;
	stMessage.MessageNumber	:= E_MessageNumbers.FF_Unknown;
	stMessage.nModuleID		:= 0;
END_IF

// Estop function faults
IF iEstopFunctionFault THEN 
	GVL_HMI.bEstopActive 	:= TRUE ;
	GVL_HMI.sCmdEstopText 	:= 'Safety button fault check button wiring';
	IF NOT qbSafetyErrAckn AND NOT TofSafetyErrAck.Q THEN 
		qbSafetyErrAckn := TRUE ;
	ELSE
		qbSafetyErrAckn := FALSE; 
	END_IF
	stMessage.Active 		:= TRUE ;
	stMessage.ComponentType	:= E_ComponentTypes.SafeIO ;
	stMessage.Discription	:= 'Emergency stop fault, check emergency button wiring ';
	stMessage.LocationName	:= 'Emergency stop safety';
	stMessage.LocationNumber:= 1;
	stMessage.FaultType		:= Utilities_Library.E_FaultTypes.FF;
	stMessage.MessageNumber	:= E_MessageNumbers.FF_Unknown;
	stMessage.nModuleID		:= 0;
END_IF

// System safety function faults
IF iSystemSafetyFault THEN 
	GVL_HMI.bEstopActive 	:= TRUE ;
	GVL_HMI.sCmdEstopText 	:= 'Collision detected';
	IF NOT qbSafetyErrAckn AND NOT TofSafetyErrAck.Q THEN 
		qbSafetyErrAckn := TRUE ;
	ELSE
		qbSafetyErrAckn := FALSE; 
	END_IF
	stMessage.Active 		:= TRUE ;
	stMessage.ComponentType	:= E_ComponentTypes.SafeIO ;
	stMessage.Discription	:= 'Collision safety fault, check collision detection wiring ';
	stMessage.LocationName	:= 'Collision safety';
	stMessage.LocationNumber:= 1;
	stMessage.FaultType		:= Utilities_Library.E_FaultTypes.FF;
	stMessage.MessageNumber	:= E_MessageNumbers.FF_Unknown;
	stMessage.nModuleID		:= 0;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSemiAuto" Id="{d1439c2c-5160-4c2a-96fa-c7dd6421b071}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PUBLIC ExecSemiAuto : BOOL
VAR
	i : UDINT ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Run automatic function in 
FOR i := 0 TO nNumberOfModules DO 
	arpModules[i].pFunction^.CmdSemiAuto() ;
END_FOR

ExecSemiAuto := bSemiAuto;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecSystemRun" Id="{504c7dee-e26b-448e-99d5-004a6dc8da1e}" FolderPath="SystemFunction\">
      <Declaration><![CDATA[METHOD INTERNAL ExecSystemRun : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set system variables 
fbSetSystemVariables();

// Check for system commands
IF fbCmdResetSafety.bFcoDelay THEN 
	eStateSystem := E_StateSystem.NoReference ;
ELSIF eStateSystem > E_StateSystem.Enable THEN 
	IF GVL_Message.bResetFaults OR fbCmdResetSafety.bFeStatus THEN
		bResetDone		:= FALSE ;
		eStateSystem 	:= E_StateSystem.Reset ;
	ELSIF fbCmdPowerOff.bFcoDelay THEN 
		eStateSystem := E_StateSystem.PowerOff ;
	ELSIF bFatalFault THEN 
		eStateSystem := E_StateSystem.Enable;
	ELSIF bCycleFault THEN 
		IF eStateSystem > E_StateSystem.Idle THEN
			eStateSystem := E_StateSystem.Idle ;
		ELSE
			eStateSystem := E_StateSystem.Enable ;
		END_IF
	ELSIF fbCmdStartSystem.bFeStatus AND eStateSystem = E_StateSystem.Idle THEN 
		bStartSemiAuto := TRUE ;
	END_IF
	
// Check for safety state
	IF NOT ibEstopOk OR NOT fbAirpressureOk.bFcoDelay THEN
		eStateSystem := E_StateSystem.Enable ;
	ELSIF NOT ibSystemSafetyOK THEN
		IF eStateSystem > E_StateSystem.Idle THEN
			eStateSystem := E_StateSystem.Idle ;
		ELSE
			eStateSystem := E_StateSystem.Enable ;
		END_IF
	END_IF
ELSE 
	IF GVL_Message.bResetFaults OR fbCmdResetSafety.bFeStatus THEN
		bResetDone := FALSE;
		bResetting := TRUE ;
	ELSIF fbCmdPowerOff.bFcoDelay THEN 
		eStateSystem := E_StateSystem.PowerOff ;
	END_IF
END_IF

// add manual function	
	
// State machine 
CASE eStateSystem OF 
	E_StateSystem.NoReference:
		HMI_Library.GVL_HMI.bCmdSemiAuto 	:= FALSE;
		HMI_Library.GVL_HMI.bCmdAutomatic	:= FALSE;
		bHomed			:= FALSE ;
		bEnabled		:= FALSE ;
		IF NOT bReferenceOk THEN
			; 
		ELSIF NOT bFatalFault AND NOT binitialized THEN 
			eStateSystem 	:= E_StateSystem.Initialize ;
		ELSIF NOT bFatalFault THEN 
			eStateSystem 	:= E_StateSystem.LoadParameters ;
		END_IF
	E_StateSystem.Initialize:
		IF Init() THEN
			eStateSystem := E_StateSystem.LoadParameters	;
		END_IF
	E_StateSystem.LoadParameters:
		IF GVL_Parameters.fbParameterHandler.Init() THEN
			eStateSystem := E_StateSystem.Enable ;
		ELSIF GVL_Parameters.fbParameterHandler.bError THEN 
			eStateSystem := E_StateSystem.NoReference ;
		END_IF
	E_StateSystem.Enable:
		IF GVL_HMI.bCmdManual THEN
			eStateSystem := E_StateSystem.Manual ;
		ELSIF bEnabled AND bSystemOK THEN 
			fbCmdStartSystem.CmdBlinkFast();
			IF fbCmdStartSystem.bFeStatus THEN
				eStateSystem := E_StateSystem.Home ;
			END_IF
		ELSIF bFatalFault THEN 
			bEnabling	:= FALSE ;
		ELSE
			bEnabling 	:= bSystemOK;
		END_IF
	E_StateSystem.Home:	
		IF ExecHoming() THEN
			eStateSystem := E_StateSystem.Idle;
		END_IF
	E_StateSystem.Reset:
		IF bResetDone AND bHomed THEN
			eStateSystem := E_StateSystem.Idle ;
		ELSIF bResetDone THEN 
			eStateSystem := E_StateSystem.Enable ;
		ELSE
			bResetting S= TRUE ;
		END_IF
	E_StateSystem.Idle:
		fbCmdStartSystem.CmdBlinkSlow();
		IF GVL_HMI.bCmdManual THEN 
			eStateSystem := E_StateSystem.Manual ;
		ELSIF bSystemOK AND bStartAuto THEN
			eStateSystem := E_StateSystem.Automatic ;
		ELSIF bSystemOK AND bStartSemiAuto THEN 
			eStateSystem := E_StateSystem.SemiAuto ;
		ELSIF bSystemOK AND GVL_DevManual.bManualModeActive THEN
			eStateSystem	:= E_StateSystem.Manual ;
		END_IF
	E_StateSystem.SemiAuto:
		ExecSemiAuto();
		GVL_HMI.bCmdSemiAuto 	:= TRUE;
		IF fbCmdStartAuto.bFeStatus OR fbStartAuto.bFcoInputActive THEN 
			bStartAuto 		:= TRUE ;
			eStateSystem 	:= E_StateSystem.Automatic ;
		END_IF					
	E_StateSystem.Automatic:
		ExecAutomatic();
		Gvl_HMI.bCmdAutomatic := TRUE;
		IF bAutomatic AND fbCmdStartSystem.bFeStatus THEN  
			eStateSystem := E_StateSystem.Idle ;
		ELSIF bAutomatic AND fbCmdStartAuto.bFeStatus THEN  
			eStateSystem := E_StateSystem.SemiAuto ;
		ELSIF bAutomatic THEN 
			fbCmdStartAuto.CmdOn();
		ELSIF NOT bAutomatic AND NOT bStartAuto THEN 
			eStateSystem := E_StateSystem.SemiAuto ;
		ELSE 
			fbCmdStartAuto.CmdBlinkFast(); 				
		END_IF
	E_StateSystem.Manual:
		IF GVL_DevManual.bManualModeActive THEN
			ExecManual();
		END_IF
		
		IF NOT GVL_HMI.bCmdManual THEN
			EStateSystem := E_StateSystem.Enable;
		END_IF 
	E_StateSystem.PowerOff:
		ExecPowerOff();
	ELSE 
		;		
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{77ed26c7-8922-4741-8b27-ccc11849164f}" FolderPath="ModuleFunctions\">
      <Declaration><![CDATA[METHOD PRIVATE Init : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// initialize system functions
fbAirpressureOk.Init	( 	nId 		:= 1,
							nParentId	:= 1 );
fbCmdResetSafety.Init	(	nId 		:= 2,
							nParentId	:= 1 );

fbValveMainAirSupply.Init(	nId			:= 3,
							nParentId	:= 1,
							eResetState	:= E_ValveResetState.Res_Closed,
							eSafeState	:= E_ValveResetState.Res_Closed);

fbCmdStartSystem.Init	( 	nId 		:= 4,
							nParentId	:= 1 );

fbCmdStartAuto.Init		( 	nId 		:= 5,
							nParentId	:= 1 );
							
// Initialize all modules
binitialized	:= TRUE ;
FOR i := 0 TO nNumberOfModules DO 
	IF NOT arpModules[i].pFunction^.binitialized THEN 
		arpModules[i].pFunction^.CmdInit();
	END_IF
	binitialized 	:= binitialized AND arpModules[i].pFunction^.binitialized;
	bInitializing 	:= NOT binitialized ;
	// Set feedback to screen (needs to be added)
 END_FOR
 
 Init := binitialized ;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>